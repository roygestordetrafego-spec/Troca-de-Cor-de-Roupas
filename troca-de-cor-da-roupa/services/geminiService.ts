
import { GoogleGenAI } from "@google/genai";

/**
 * Converts a base64 string (with data URI header) to raw base64 string
 */
const cleanBase64 = (dataUri: string): string => {
  return dataUri.split(',')[1] || dataUri;
};

/**
 * Identify the mime type from the data URI
 */
const getMimeType = (dataUri: string): string => {
  const match = dataUri.match(/^data:(.+);base64,/);
  return match ? match[1] : 'image/png';
};

/**
 * Helper function to execute a task with exponential backoff retry logic.
 * Primarily handles 503 (overloaded) and 429 (rate limit) errors.
 */
async function withRetry<T>(task: () => Promise<T>, maxRetries = 3): Promise<T> {
  let lastError: any;
  for (let i = 0; i <= maxRetries; i++) {
    try {
      return await task();
    } catch (error: any) {
      lastError = error;
      const errorMessage = error.message || "";
      const isRetryable = errorMessage.includes("503") || 
                          errorMessage.includes("overloaded") || 
                          errorMessage.includes("429") || 
                          errorMessage.includes("rate limit") ||
                          errorMessage.includes("Internal error");
      
      if (isRetryable && i < maxRetries) {
        const delay = Math.pow(2, i) * 1500 + Math.random() * 1000;
        console.warn(`Gemini API issue. Retrying in ${Math.round(delay)}ms... (Attempt ${i + 1}/${maxRetries})`);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      throw error;
    }
  }
  throw lastError;
}

export const editImageWithGemini = async (
  imageBase64: string, 
  prompt: string
): Promise<string> => {
  
  const currentApiKey = process.env.API_KEY;
  if (!currentApiKey) throw new Error("API Key is missing. Please connect your Google AI Studio project.");

  return withRetry(async () => {
    // CRITICAL: Always create a new instance right before the call to use the latest key
    const ai = new GoogleGenAI({ apiKey: currentApiKey });
    const model = "gemini-3-pro-image-preview"; 
    const mimeType = getMimeType(imageBase64);
    const rawData = cleanBase64(imageBase64);

    const response = await ai.models.generateContent({
      model: model,
      contents: {
        parts: [
          {
            text: prompt
          },
          {
            inlineData: {
              mimeType: mimeType,
              data: rawData
            }
          }
        ]
      },
      config: {
        imageConfig: {
          imageSize: "2K", // Start with 2K for stability, can be 4K but prone to internal errors
          aspectRatio: "3:4" 
        }
      }
    });

    const parts = response.candidates?.[0]?.content?.parts;
    
    if (!parts) {
      throw new Error("No content generated by the model. The prompt might have been blocked or the model encountered an issue.");
    }

    let generatedImage = '';

    for (const part of parts) {
      if (part.inlineData && part.inlineData.data) {
        generatedImage = `data:image/png;base64,${part.inlineData.data}`;
        break;
      }
    }

    if (!generatedImage) {
      const textPart = parts.find(p => p.text);
      if (textPart) {
        throw new Error(`Model returned text instead of image: ${textPart.text}`);
      }
      throw new Error("Model finished but returned no image data.");
    }

    return generatedImage;
  });
};

export const generateVideoWithGemini = async (
  prompt: string,
  imageBase64?: string
): Promise<string> => {
  const currentApiKey = process.env.API_KEY;
  if (!currentApiKey) throw new Error("API Key is missing. Please connect your Google AI Studio project.");

  return withRetry(async () => {
    const ai = new GoogleGenAI({ apiKey: currentApiKey });
    
    let operation = await ai.models.generateVideos({
      model: 'veo-3.1-fast-generate-preview',
      prompt: prompt,
      image: imageBase64 ? {
        imageBytes: cleanBase64(imageBase64),
        mimeType: getMimeType(imageBase64),
      } : undefined,
      config: {
        numberOfVideos: 1,
        resolution: '720p',
        aspectRatio: '16:9'
      }
    });

    while (!operation.done) {
      await new Promise(resolve => setTimeout(resolve, 10000));
      operation = await ai.operations.getVideosOperation({ operation: operation });
    }

    const downloadLink = operation.response?.generatedVideos?.[0]?.video?.uri;
    if (!downloadLink) throw new Error("Video generation completed but no link was returned.");

    const response = await fetch(`${downloadLink}&key=${currentApiKey}`);
    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Fetch failed: ${response.status} ${errorText}`);
    }
    const blob = await response.blob();
    return URL.createObjectURL(blob);
  });
};
